# Отчет: единый Mini App для Telegram и MAX

**Дата:** 19 февраля 2026 г.  
**Статус:** Технический анализ и рекомендации к внедрению  
**Версия:** 1.0

## 1. Цель отчета

Оценить, насколько реально использовать один клиентский проект (`telegram-miniapp`) одновременно в двух платформах:

- Telegram Mini App
- MAX Mini App

Отчет ориентирован на текущую кодовую базу FoodMiniApp и описывает практический путь реализации без дублирования фронтенда.

## 2. Краткий итог

Реализация одного проекта под две платформы является реалистичной.

**Оценка реализуемости:** высокая (порядка 8/10) при условии, что:

- платформенные API инкапсулируются в отдельный слой (Bridge Adapter);
- backend-авторизация поддерживает обе схемы `initData`;
- модель пользователя расширяется для мультиплатформенной идентификации.

## 3. На чем основана оценка

### 3.1 Текущее состояние клиентского кода

В проекте уже есть единый сервисный слой для Telegram API:

- `telegram-miniapp/src/shared/services/telegram.js`
- `telegram-miniapp/src/shared/stores/telegram.js`

Это хорошая отправная точка: большая часть экранов не обращается к `window.Telegram.WebApp` напрямую, а идет через абстракции.

### 3.2 Текущее состояние backend-авторизации

Сейчас авторизация клиента жестко привязана к Telegram:

- `backend/src/modules/auth/routes.js`
- `backend/src/utils/telegram.js`

Ключевые особенности текущей реализации:

- вход через `/api/auth/telegram`;
- проверка подписи `initData` по Telegram-алгоритму;
- связь пользователя с `telegram_id`.

Это означает, что для MAX потребуется расширение auth-слоя и схемы идентификации.

## 4. Совместимость по функционалу

По доступной документации MAX Mini Apps и Bridge, базовые сценарии, нужные FoodMiniApp, достижимы:

- инициализация mini app;
- получение и валидация данных запуска;
- управление нативными кнопками (главная/назад);
- запрос контактных данных пользователя;
- открытие ссылок;
- хранение данных в безопасном платформенном хранилище (вместо прямой привязки к Telegram CloudStorage).

Важно закладывать fallback-поведение, так как отдельные методы могут отличаться по деталям или уровню поддержки.

## 5. Что нужно изменить в проекте

## 5.1 Frontend: платформенный адаптер

Вместо прямой зависимости от Telegram API нужен интерфейс платформенного моста.

Рекомендуемая структура:

- `telegram-miniapp/src/shared/platform/bridge.js` (контракт)
- `telegram-miniapp/src/shared/platform/telegramBridge.js`
- `telegram-miniapp/src/shared/platform/maxBridge.js`
- `telegram-miniapp/src/shared/platform/index.js` (резолвер активной платформы)

Контракт адаптера должен покрывать используемые методы:

- `init()`
- `getInitData()`
- `getUser()`
- `showBackButton()/hideBackButton()`
- `setMainButton()/hideMainButton()`
- `hapticFeedback()`
- `requestContact()`
- `storage.get/set/remove()`
- `openLink()`

После этого модули авторизации, роутера и UI продолжают работать через единый интерфейс.

## 5.2 Backend: универсальная авторизация Mini App

Рекомендуется заменить платформо-зависимый вход на универсальный endpoint:

- `POST /api/auth/miniapp`

Пример входного payload:

```json
{
  "platform": "telegram",
  "initData": "..."
}
```

или

```json
{
  "platform": "max",
  "initData": "..."
}
```

Далее backend:

- выбирает валидатор подписи по `platform`;
- извлекает внешний user id;
- выполняет upsert пользователя;
- выдает JWT текущего формата.

## 5.3 База данных: идентификация пользователей

Текущая связь только через `users.telegram_id` ограничивает мультиплатформенность.

Рекомендуется перейти к одной из моделей:

1. Минимальная: добавить в `users` поле `max_id`.
2. Масштабируемая: отдельная таблица `user_external_accounts`:

- `user_id`
- `platform` (`telegram`, `max`, далее расширяемо)
- `external_id`
- уникальный индекс `(platform, external_id)`

Для долгосрочного развития лучше второй вариант.

## 5.4 Бизнес-логика и аналитика

Где сейчас используется `telegram_id`, нужно перейти на платформенно-нейтральный подход:

- сегментация и рассылки;
- служебные уведомления;
- аудит источника регистрации/входа;
- отчеты по каналам привлечения.

Рекомендуется добавить поле источника в события аналитики (`source_platform`).

## 6. Риски и ограничения

1. Различия в валидации `initData` между платформами.
2. Различия в поведении bridge-событий (особенно на старых клиентах).
3. Частичная совместимость отдельных методов bridge.
4. Текущая backend-логика и часть админ-функций завязаны на `telegram_id`.

## 7. Оценка трудозатрат

При текущей архитектуре проекта:

- **MVP-интеграция (единый фронт + dual auth):** 4-8 рабочих дней.
- **Полная стабилизация (мониторинг, edge-cases, аналитика):** +3-5 рабочих дней.

Итого для production-ready этапа: **7-13 рабочих дней**.

## 8. Рекомендуемый план внедрения

1. Вынести текущие Telegram-вызовы в адаптерный слой платформы.
2. Реализовать `TelegramBridge` и `MaxBridge`.
3. Добавить backend endpoint `POST /api/auth/miniapp`.
4. Внедрить платформенно-нейтральную схему внешних аккаунтов пользователя.
5. Прогнать smoke/e2e сценарии на двух платформах:
   - вход;
   - запрос контакта;
   - оформление заказа;
   - работа кнопок и навигации;
   - работа хранилища токена.
6. Добавить feature flag для поэтапного запуска MAX.

## 9. Рекомендация

Для FoodMiniApp целесообразно идти по модели **один клиентский проект + платформенные адаптеры + универсальный backend auth**.

Подход снижает стоимость сопровождения по сравнению с двумя отдельными клиентами и минимизирует риск расхождения бизнес-логики между платформами.

## 10. Источники

- MAX Developer Docs: `https://dev.max.ru/docs`
- MAX Mini Apps: `https://dev.max.ru/docs/mini-apps/intro`
- MAX Bridge: `https://dev.max.ru/docs/mini-apps/bridge`
- MAX Authorization: `https://dev.max.ru/docs/mini-apps/authorization`
- Telegram Web Apps: `https://core.telegram.org/bots/webapps`
- Telegram initData validation: `https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app`
