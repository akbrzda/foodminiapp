# Техническое задание: Модуль маркетинговых рассылок через Telegram

## Содержание

1. [Общее описание](#1-общее-описание)
2. [Функциональные требования](#2-функциональные-требования)
3. [Архитектура базы данных](#3-архитектура-базы-данных)
4. [Бизнес-логика](#4-бизнес-логика)
5. [API спецификация](#5-api-спецификация)
6. [Интерфейс администратора](#6-интерфейс-администратора)  
7. [Интеграция с существующей системой](#7-интеграция-с-существующей-системой)
8. [Технические требования](#8-технические-требования)
9. [Этапы разработки](#9-этапы-разработки)
10. [Риски и ограничения](#10-риски-и-ограничения)

---

## 1. Общее описание

### 1.1 Назначение модуля

Модуль маркетинговых рассылок предназначен для отправки целевых сообщений клиентам через Telegram Bot API с целью:
- Увеличения повторных заказов
- Возврата спящих клиентов
- Информирования о промо-акциях и новинках
- Повышения лояльности клиентов
- Персонализированных коммуникаций

### 1.2 Основные возможности

- **Сегментация аудитории** по множественным критериям с логическими операторами (AND/OR)
- **Создание рассылок** с текстом, изображениями, кнопками и персонализацией через плейсхолдеры
- **Планирование отправки** с учетом часовых поясов пользователей
- **Триггерные рассылки** на основе событий (отсутствие заказов, день рождения)
- **Статистика и аналитика** эффективности рассылок  
- **Очередь отправки** для соблюдения лимитов Telegram Bot API (30 сообщений/секунду)
- **WYSIWYG редактор** для создания контента
- **Предпросмотр и тестирование** перед отправкой

### 1.3 Ключевые отличия от существующих уведомлений

Модуль работает с тем же Telegram ботом, который используется для уведомлений по заказам, но имеет:
- Отдельную очередь обработки
- Собственную систему учета статистики
- Механизм планирования и триггеров
- Отслеживание переходов по ссылкам и конверсий

---

## 2. Функциональные требования

### 2.1 Сегментация аудитории

#### 2.1.1 Критерии сегментации

**По активности:**
- Спящие клиенты (не заказывали N дней)
- Активные клиенты (заказывают регулярно в период)
- Новые клиенты (зарегистрировались в период)
- Период заказов: от даты X до даты Y
- Период отсутствия заказов: последний заказ более N дней назад

**По финансовым показателям:**
- Общая сумма заказов: от X до Y рублей
- Средний чек: от X до Y рублей
- Количество заказов: от X до Y

**По географии:**
- Город
- Филиал

**По клиенту:**
- Дата рождения (месяц, день, диапазон дат)
- Уровень лояльности (Бронза, Серебро, Золото)
- Баланс бонусов: от X до Y

#### 2.1.2 Логические операторы

Сегменты можно комбинировать с помощью операторов:
- **AND** (И) - все условия должны выполняться
- **OR** (ИЛИ) - хотя бы одно условие должно выполняться

Пример: "Спящие клиенты ИЗ Москвы ИЛИ Питера И с общей суммой заказов > 10000₽"

#### 2.1.3 Сохраненные сегменты

Возможность сохранить настроенный сегмент для повторного использования с названием и описанием.

### 2.2 Типы рассылок

#### 2.2.1 Ручные рассылки
- Создание администратором
- Отправка сразу или по расписанию
- Одноразовая отправка

#### 2.2.2 Триггерные рассылки
Автоматические рассылки, запускаемые по условиям:
- **Отсутствие заказов N дней** (3, 7, 30, 60, 90 дней)
- **День рождения через N дней** (за 7, 3, 1 день, в день)
- **Новая регистрация** (через N часов/дней после регистрации)

Триггеры проверяются ежедневно в заданное время.

### 2.3 Контент рассылок

#### 2.3.1 Элементы сообщения

**Текст:**
- Максимум 4096 символов (ограничение Telegram)
- Поддержка Markdown разметки
- Поддержка плейсхолдеров для персонализации

**Изображение:**
- Опционально
- Форматы: JPG, PNG
- Максимальный размер: 10 МБ
- Загрузка через админ-панель

**Кнопки (Inline Keyboard):**
- До 8 кнопок
- Типы кнопок:
  - URL (ссылка на внешний ресурс или Mini App)
  - Callback (для трекинга переходов)

#### 2.3.2 Плейсхолдеры (персонализация)

Доступные плейсхолдеры для подстановки данных клиента:
- `{first_name}` - имя пользователя
- `{last_name}` - фамилия пользователя
- `{phone}` - номер телефона
- `{loyalty_level}` - уровень лояльности (Бронза/Серебро/Золото)
- `{bonus_balance}` - баланс бонусов
- `{days_since_order}` - дней с последнего заказа
- `{total_orders}` - количество заказов
- `{total_spent}` - общая сумма заказов

Пример текста:
```
Привет, {first_name}! 
Мы скучали по тебе последние {days_since_order} дней. 
Специально для вас - скидка 15% на любой заказ!
Ваш баланс: {bonus_balance} бонусов.
```

### 2.4 Планирование отправки

#### 2.4.1 Немедленная отправка
Рассылка начинается сразу после подтверждения

#### 2.4.2 Отложенная отправка
- Выбор даты и времени отправки
- Учет часового пояса каждого пользователя
- Указывается время в локальном часовом поясе пользователя

Пример: Отправка в 10:00 по местному времени каждого получателя

#### 2.4.3 Часовые пояса

Система определяет часовой пояс пользователя:
- По городу из профиля пользователя
- Если город не указан - используется UTC+3 (Москва)

Маппинг городов к часовым поясам хранится в конфигурации.

### 2.5 Статистика и аналитика

#### 2.5.1 Метрики рассылки

**Основные метрики:**
- Всего в сегменте (количество пользователей соответствующих условиям)
- Отправлено (попало в очередь)
- Доставлено (успешно отправлено через Telegram API)
- Ошибки отправки (ошибки Telegram API, заблокированный бот)
- Переходы по ссылкам (клики по кнопкам с URL)
- Конверсия в заказы (заказы сделанные в течение 7 дней после получения рассылки)

**Дополнительные метрики:**
- Время полной отправки рассылки
- Средняя скорость отправки (сообщений/минуту)

#### 2.5.2 Отслеживание конверсий

Система отслеживает заказы, сделанные в течение 7 дней после отправки рассылки:
- Связывает заказы с рассылкой через `broadcast_id`
- Считает количество заказов
- Считает сумму заказов
- Рассчитывает ROI (если в рассылке была информация о затратах)

#### 2.5.3 Отслеживание переходов

Для отслеживания переходов по ссылкам:
- Генерируются уникальные ссылки с параметром `?utm_source=broadcast_{id}&utm_user={user_id}`
- При переходе по ссылке фиксируется событие через webhook или специальный эндпоинт
- Хранится timestamp перехода

### 2.6 WYSIWYG редактор

Визуальный редактор для создания контента рассылки:
- Форматирование текста (жирный, курсив, подчеркнутый)
- Вставка плейсхолдеров из выпадающего списка
- Загрузка изображения drag-and-drop
- Предпросмотр изображения
- Добавление/удаление кнопок
- Настройка текста и URL для каждой кнопки

### 2.7 Тестирование рассылок

Перед отправкой администратор может:
- **Предпросмотреть** сообщение с подставленными реальными данными (выбрать пользователя)
- **Отправить тестовое сообщение** себе в Telegram
- **Проверить размер аудитории** по выбранному сегменту

---

## 3. Архитектура базы данных

### 3.1 Таблица: broadcast_campaigns

Хранит информацию о рассылках.

**Поля:**
- `id` (INTEGER, PK, AUTO_INCREMENT)
- `name` (VARCHAR(255)) - название рассылки
- `description` (TEXT, nullable) - описание рассылки
- `type` (ENUM: 'manual', 'trigger') - тип рассылки  
- `status` (ENUM: 'draft', 'scheduled', 'sending', 'completed', 'cancelled', 'failed') - статус
- `trigger_type` (ENUM: 'inactive_users', 'birthday', 'new_registration', nullable) - тип триггера
- `trigger_config` (JSON, nullable) - конфигурация триггера
- `segment_id` (INTEGER, FK → broadcast_segments.id, nullable) - сохраненный сегмент
- `segment_config` (JSON) - конфигурация сегментации
- `content_text` (TEXT) - текст сообщения с плейсхолдерами
- `content_image_url` (VARCHAR(500), nullable) - URL изображения
- `content_buttons` (JSON, nullable) - массив кнопок
- `scheduled_at` (TIMESTAMP, nullable) - запланированное время отправки
- `use_user_timezone` (BOOLEAN, default: true) - учитывать часовой пояс
- `target_hour` (INTEGER, nullable) - час отправки (0-23)
- `is_active` (BOOLEAN, default: true) - активна ли триггерная рассылка
- `created_by` (INTEGER, FK → admins.id)
- `started_at` (TIMESTAMP, nullable) - когда началась отправка
- `completed_at` (TIMESTAMP, nullable) - когда завершена отправка
- `created_at` (TIMESTAMP)
- `updated_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`type`)
- INDEX (`status`)
- INDEX (`trigger_type`)
- INDEX (`scheduled_at`)
- INDEX (`is_active`)
- INDEX (`created_by`)
- INDEX (`created_at`)

---

### 3.2 Таблица: broadcast_segments

Хранит сохраненные сегменты аудитории.

**Поля:**
- `id` (INTEGER, PK, AUTO_INCREMENT)
- `name` (VARCHAR(255)) - название сегмента
- `description` (TEXT, nullable) - описание сегмента
- `config` (JSON) - конфигурация сегментации
- `estimated_size` (INTEGER, nullable) - примерный размер аудитории
- `estimated_at` (TIMESTAMP, nullable) - когда рассчитан размер
- `created_by` (INTEGER, FK → admins.id)
- `created_at` (TIMESTAMP)
- `updated_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`created_by`)
- INDEX (`created_at`)

---

### 3.3 Таблица: broadcast_messages

Хранит индивидуальные сообщения для каждого получателя.

**Поля:**
- `id` (BIGINT, PK, AUTO_INCREMENT)
- `campaign_id` (INTEGER, FK → broadcast_campaigns.id)
- `user_id` (INTEGER, FK → users.id)
- `status` (ENUM: 'pending', 'sending', 'sent', 'failed')
- `telegram_message_id` (BIGINT, nullable) - ID сообщения в Telegram
- `personalized_text` (TEXT) - текст с подставленными плейсхолдерами
- `scheduled_at` (TIMESTAMP, nullable) - время отправки
- `sent_at` (TIMESTAMP, nullable) - фактическое время отправки
- `error_message` (TEXT, nullable) - сообщение об ошибке
- `retry_count` (INTEGER, default: 0) - количество попыток
- `created_at` (TIMESTAMP)
- `updated_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`campaign_id`)
- INDEX (`user_id`)
- INDEX (`status`)
- INDEX (`scheduled_at`)
- INDEX (`campaign_id`, `status`)
- INDEX (`status`, `scheduled_at`)
- INDEX (`status`, `retry_count`)

---

### 3.4 Таблица: broadcast_clicks

Хранит информацию о кликах по кнопкам.

**Поля:**
- `id` (BIGINT, PK, AUTO_INCREMENT)
- `campaign_id` (INTEGER, FK → broadcast_campaigns.id)
- `message_id` (BIGINT, FK → broadcast_messages.id)
- `user_id` (INTEGER, FK → users.id)
- `button_index` (INTEGER) - индекс кнопки (0, 1, 2...)
- `button_url` (VARCHAR(500)) - URL кнопки
- `clicked_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`campaign_id`)
- INDEX (`message_id`)
- INDEX (`user_id`)
- INDEX (`clicked_at`)
- UNIQUE (`message_id`, `button_index`, `user_id`)

---

### 3.5 Таблица: broadcast_conversions

Связывает заказы с рассылками для расчета конверсии.

**Поля:**
- `id` (BIGINT, PK, AUTO_INCREMENT)
- `campaign_id` (INTEGER, FK → broadcast_campaigns.id)
- `message_id` (BIGINT, FK → broadcast_messages.id)
- `user_id` (INTEGER, FK → users.id)
- `order_id` (INTEGER, FK → orders.id)
- `order_total` (DECIMAL(10,2)) - сумма заказа
- `order_created_at` (TIMESTAMP) - дата создания заказа
- `days_after_broadcast` (INTEGER) - дней после получения рассылки
- `created_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`campaign_id`)
- INDEX (`message_id`)
- INDEX (`user_id`)
- INDEX (`order_id`)
- UNIQUE (`order_id`)

---

### 3.6 Таблица: broadcast_queue

Очередь отправки сообщений.

**Поля:**
- `id` (BIGINT, PK, AUTO_INCREMENT)
- `message_id` (BIGINT, FK → broadcast_messages.id)
- `priority` (INTEGER, default: 0) - приоритет
- `scheduled_at` (TIMESTAMP) - когда отправлять
- `locked_at` (TIMESTAMP, nullable) - блокировка для обработки
- `locked_by` (VARCHAR(100), nullable) - ID воркера
- `created_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- INDEX (`message_id`)
- INDEX (`scheduled_at`, `locked_at`, `priority`)
- INDEX (`locked_by`)

---

### 3.7 Таблица: broadcast_stats

Агрегированная статистика по рассылкам.

**Поля:**
- `id` (INTEGER, PK, AUTO_INCREMENT)
- `campaign_id` (INTEGER, FK → broadcast_campaigns.id, UNIQUE)
- `total_recipients` (INTEGER, default: 0)
- `sent_count` (INTEGER, default: 0)
- `failed_count` (INTEGER, default: 0)
- `click_count` (INTEGER, default: 0)
- `unique_clicks` (INTEGER, default: 0)
- `conversion_count` (INTEGER, default: 0)
- `conversion_amount` (DECIMAL(10,2), default: 0.00)
- `avg_send_time_seconds` (INTEGER, nullable)
- `updated_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- UNIQUE (`campaign_id`)

---

### 3.8 Таблица: broadcast_trigger_log

Лог выполнения триггерных рассылок для предотвращения дубликатов.

**Поля:**
- `id` (BIGINT, PK, AUTO_INCREMENT)
- `campaign_id` (INTEGER, FK → broadcast_campaigns.id)
- `user_id` (INTEGER, FK → users.id)
- `trigger_date` (DATE) - дата срабатывания триггера
- `executed_at` (TIMESTAMP)

**Индексы:**
- PRIMARY KEY (`id`)
- UNIQUE (`campaign_id`, `user_id`, `trigger_date`)
- INDEX (`executed_at`)

---

### 3.9 Изменения в существующих таблицах

#### 3.9.1 Таблица: users

**Новые поля:**
- `timezone` (VARCHAR(50), nullable) - часовой пояс пользователя

**Индексы:**
- INDEX (`timezone`)

#### 3.9.2 Таблица: cities

**Новые поля:**
- `timezone` (VARCHAR(50), default: 'Europe/Moscow') - часовой пояс города

---

## 4. Бизнес-логика

### 4.1 Создание рассылки

#### 4.1.1 Ручная рассылка

**Процесс:**
1. Администратор создает новую рассылку (статус: draft)
2. Настраивает сегментацию аудитории
3. Создает контент (текст, изображение, кнопки)
4. Вставляет плейсхолдеры для персонализации
5. Выбирает время отправки (сейчас / по расписанию)
6. Тестирует рассылку (предпросмотр, тестовая отправка)
7. Подтверждает отправку

**При подтверждении:**
- Статус меняется на 'scheduled' (если отложенная) или 'sending' (если немедленная)
- Запускается процесс формирования очереди сообщений

#### 4.1.2 Триггерная рассылка

**Процесс:**
1. Администратор создает триггерную рассылку
2. Выбирает тип триггера
3. Настраивает условия (например, 30 дней без заказа)
4. Создает контент с плейсхолдерами
5. Устанавливает время проверки (например, ежедневно в 10:00)
6. Активирует триггер (is_active = true)

**Автоматическое выполнение:**
- Cron задача проверяет активные триггеры ежедневно
- Для каждого триггера выбирает пользователей, подходящих под условия
- Проверяет broadcast_trigger_log на дубликаты
- Создает сообщения для отправки
- Добавляет в очередь

### 4.2 Сегментация аудитории

#### 4.2.1 Формирование SQL запроса

На основе конфигурации сегмента (JSON) формируется SQL запрос с WHERE условиями.

**Пример структуры segment_config:**
```json
{
  "operator": "AND",
  "conditions": [
    {
      "type": "inactive_days",
      "operator": ">=",
      "value": 30
    },
    {
      "operator": "OR",
      "conditions": [
        {
          "type": "city",
          "operator": "=",
          "value": 1
        },
        {
          "type": "city",
          "operator": "=",
          "value": 2
        }
      ]
    }
  ]
}
```

#### 4.2.2 Типы условий сегментации

**inactive_days (спящие клиенты):**
- Дней с последнего заказа >= N
- Запрос: `DATEDIFF(NOW(), MAX(orders.created_at)) >= N`

**active_in_period (активные клиенты):**
- Заказы в периоде от date_from до date_to
- Запрос: `orders.created_at BETWEEN 'date_from' AND 'date_to'`

**new_users (новые клиенты):**
- Зарегистрированы в период
- Запрос: `users.created_at BETWEEN 'date_from' AND 'date_to'`

**total_spent (общая сумма заказов):**
- SUM(orders.total) оператор value
- Операторы: `<`, `>`, `=`, `<=`, `>=`, `BETWEEN`

**avg_check (средний чек):**
- AVG(orders.total) оператор value

**order_count (количество заказов):**
- COUNT(orders.id) оператор value

**city (город):**
- users.city_id = value

**branch (филиал):**
- orders.branch_id = value

**birthday_month (месяц дня рождения):**
- MONTH(users.birth_date) = value

**birthday_range (диапазон дней рождения):**
- users.birth_date BETWEEN 'date_from' AND 'date_to'

**loyalty_level (уровень лояльности):**
- users.current_loyalty_level_id = value

**bonus_balance (баланс бонусов):**
- users.loyalty_balance оператор value

#### 4.2.3 Кеширование размера сегмента

При сохранении сегмента:
- Выполняется COUNT запрос
- Результат сохраняется в `estimated_size`
- Устанавливается `estimated_at`
- Кеш обновляется каждые 24 часа автоматически

### 4.3 Формирование очереди сообщений

#### 4.3.1 Процесс создания сообщений

**При запуске рассылки (статус: sending):**

1. Выбираются пользователи по сегменту
2. Для каждого пользователя:
   - Создается запись в `broadcast_messages` (статус: pending)
   - Подставляются плейсхолдеры в текст
   - Рассчитывается время отправки с учетом часового пояса
   - Создается задача в `broadcast_queue`
3. Обновляется `broadcast_stats.total_recipients`
4. Устанавливается `campaign.started_at`

#### 4.3.2 Персонализация текста

Замена плейсхолдеров на реальные данные пользователя:

```
{first_name} → Иван
{last_name} → Иванов
{phone} → +79991234567
{loyalty_level} → Золото
{bonus_balance} → 1500
{days_since_order} → 45
{total_orders} → 23
{total_spent} → 34500
```

Если данные отсутствуют:
- `{first_name}` → "Гость" (или пустая строка)
- `{last_name}` → пустая строка
- Числовые плейсхолдеры → 0

#### 4.3.3 Расчет времени отправки с учетом часового пояса

**Если use_user_timezone = false:**
- Все сообщения отправляются в одно время
- `scheduled_at` = `campaign.scheduled_at`

**Если use_user_timezone = true:**

1. Определяется часовой пояс пользователя:
   - Из `users.timezone`
   - Если NULL, то из `cities.timezone`
   - Если и это NULL, то 'Europe/Moscow' (UTC+3)

2. Рассчитывается локальное время отправки:
   - `target_hour` (например, 10:00)
   - Конвертируется в UTC для `scheduled_at`

### 4.4 Отправка сообщений

#### 4.4.1 Воркер отправки

**Процесс:**

1. Воркер каждые 2 секунды:
   - Выбирает задачи из `broadcast_queue`:
     - `scheduled_at <= NOW()`
     - `locked_at IS NULL`
     - ORDER BY `priority DESC`, `scheduled_at ASC`
     - LIMIT 50 (батч)
   
2. Блокирует выбранные задачи:
   - UPDATE `locked_at = NOW()`, `locked_by = worker_id`

3. Для каждой задачи:
   - Получает `broadcast_messages` по `message_id`
   - Получает данные пользователя (`telegram_id`)
   - Отправляет сообщение через Telegram Bot API
   - Соблюдает лимит 30 сообщений/секунду

4. Обновляет статусы:
   - При успехе: `broadcast_messages.status = 'sent'`, `sent_at = NOW()`
   - При ошибке: `broadcast_messages.status = 'failed'`, `error_message = ...`
   - Удаляет задачу из `broadcast_queue`

5. Обновляет счетчики в `broadcast_stats`

#### 4.4.2 Обработка ошибок

**Типы ошибок Telegram API:**
- **400 Bad Request** - неверный формат (не повторять)
- **403 Forbidden** - бот заблокирован пользователем (не повторять)
- **429 Too Many Requests** - превышен лимит (повторить через N секунд)
- **500 Internal Server Error** - ошибка Telegram (повторить до 3 раз)

**Логика повторов:**
- Увеличить `retry_count`
- Если `retry_count < 3`:
  - Задержка: 5, 15, 60 секунд
  - Вернуть задачу в очередь
- Если `retry_count >= 3`:
  - Статус: failed

#### 4.4.3 Завершение рассылки

Когда все сообщения обработаны:
- Статус рассылки: completed (или failed, если все сообщения failed)
- Устанавливается `completed_at`
- Обновляется финальная статистика

### 4.5 Отслеживание кликов

#### 4.5.1 Генерация URL с трекингом

При формировании кнопок в сообщении:
- Оригинальный URL: `https://example.com/promo`
- Добавляются параметры: `?utm_source=broadcast_123&utm_user=456`

#### 4.5.2 Фиксация клика

**Через Telegram Callback Query:**
- Кнопка типа: `callback_data`
- При нажатии Telegram отправляет callback в бота
- Бот фиксирует клик и отвечает с URL для открытия

### 4.6 Отслеживание конверсий

#### 4.6.1 Связывание заказов с рассылками

**При создании заказа:**

1. Проверяется, получал ли пользователь рассылки за последние 7 дней
2. Если рассылки были:
   - Выбирается последняя отправленная рассылка
   - Создается запись в `broadcast_conversions`
   - Фиксируется `campaign_id`, `message_id`, `order_id`, `order_total`
   - Рассчитывается `days_after_broadcast`
3. Обновляется статистика `broadcast_stats`:
   - Увеличивается `conversion_count`
   - Увеличивается `conversion_amount`

**Примечание:** Один заказ может быть связан только с одной рассылкой.

### 4.7 Триггерные рассылки

#### 4.7.1 Типы триггеров

**1. Отсутствие заказов N дней (inactive_users)**

**Конфигурация:**
```json
{
  "days": 30,
  "check_time": "10:00"
}
```

**Логика:**
- Ежедневно в `check_time` запускается проверка
- Выбираются пользователи с последним заказом более `days` дней назад
- Проверяется `broadcast_trigger_log` на дубликаты
- Создаются сообщения для отправки

**2. День рождения через N дней (birthday)**

**Конфигурация:**
```json
{
  "days_before": 7,
  "check_time": "09:00"
}
```

**Логика:**
- Ежедневно в `check_time` запускается проверка
- Выбираются пользователи, у которых ДР через `days_before` дней
- Проверяется `broadcast_trigger_log` на дубликаты
- Создаются сообщения для отправки

**3. Новая регистрация (new_registration)**

**Конфигурация:**
```json
{
  "hours_after": 24,
  "check_time": "12:00"
}
```

**Логика:**
- Ежедневно в `check_time` запускается проверка
- Выбираются пользователи, зарегистрированные `hours_after` часов назад
- Проверяется `broadcast_trigger_log` на дубликаты
- Создаются сообщения для отправки

#### 4.7.2 Cron задача для триггеров

**Расписание:** Запускается ежечасно

**Процесс:**
1. Выбираются активные триггерные рассылки
2. Для каждой рассылки проверяется время проверки
3. Если да:
   - Выполняется запрос выборки пользователей
   - Для каждого пользователя создается запись в `broadcast_trigger_log`
   - Создаются `broadcast_messages` и задачи в `broadcast_queue`

### 4.8 Статистика и отчеты

#### 4.8.1 Агрегация статистики

**Обновление broadcast_stats происходит:**
- После каждой отправленной партии сообщений (batch)
- По завершении рассылки
- По запросу (ручной пересчет)

---

Продолжение в следующей части...

## 5. API спецификация

### 5.1 Эндпоинты для рассылок

#### POST /api/broadcasts
Создание новой рассылки.

**Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "name": "Возврат спящих клиентов",
    "status": "draft",
    "created_at": "2024-01-25T12:00:00Z"
  }
}
```

#### GET /api/broadcasts
Список всех рассылок с фильтрацией.

**Query Parameters:**
- `page` (integer, default: 1)
- `limit` (integer, default: 20, max: 100)
- `type` (enum: manual, trigger)
- `status` (enum: draft, scheduled, sending, completed, cancelled, failed)
- `search` (string)

**Response (200):**
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 45,
      "pages": 3
    }
  }
}
```

#### GET /api/broadcasts/:id
Получение детальной информации о рассылке.

**Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "name": "Возврат спящих клиентов",
    "type": "manual",
    "status": "completed",
    "stats": {...},
    "created_at": "2024-01-25T12:00:00Z"
  }
}
```

#### PUT /api/broadcasts/:id
Обновление рассылки (только в статусе draft).

#### DELETE /api/broadcasts/:id
Удаление рассылки (только в статусе draft).

#### POST /api/broadcasts/:id/send
Запуск отправки рассылки.

**Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "status": "sending",
    "total_recipients": 1500,
    "started_at": "2024-02-01T10:00:00Z"
  }
}
```

#### POST /api/broadcasts/:id/cancel
Отмена рассылки (только в статусе scheduled или sending).

#### POST /api/broadcasts/:id/test
Отправка тестового сообщения администратору.

**Request Body:**
```json
{
  "telegram_id": 123456789,
  "test_user_id": 456
}
```

#### POST /api/broadcasts/:id/preview
Предпросмотр сообщения с подставленными данными пользователя.

**Request Body:**
```json
{
  "user_id": 456
}
```

**Response (200):**
```json
{
  "success": true,
  "data": {
    "text": "Привет, Иван! Мы скучали...",
    "image_url": "https://...",
    "buttons": [...]
  }
}
```

### 5.2 Эндпоинты для сегментов

#### POST /api/broadcasts/segments
Создание сохраненного сегмента.

**Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 5,
    "name": "Спящие клиенты Москвы",
    "estimated_size": 1520,
    "created_at": "2024-01-25T12:00:00Z"
  }
}
```

#### GET /api/broadcasts/segments
Список сохраненных сегментов.

#### GET /api/broadcasts/segments/:id
Получение детальной информации о сегменте.

#### PUT /api/broadcasts/segments/:id
Обновление сегмента.

#### DELETE /api/broadcasts/segments/:id
Удаление сегмента.

#### POST /api/broadcasts/segments/calculate
Расчет размера аудитории по конфигурации (без сохранения).

**Response (200):**
```json
{
  "success": true,
  "data": {
    "estimated_size": 1520
  }
}
```

### 5.3 Эндпоинты для статистики

#### GET /api/broadcasts/:id/stats
Получение детальной статистики по рассылке.

**Response (200):**
```json
{
  "success": true,
  "data": {
    "overview": {
      "total_recipients": 1500,
      "sent_count": 1480,
      "failed_count": 20,
      "click_count": 245,
      "unique_clicks": 198,
      "conversion_count": 37,
      "conversion_amount": 125000
    }
  }
}
```

#### GET /api/broadcasts/:id/messages
Список сообщений рассылки с фильтрацией.

#### GET /api/broadcasts/:id/conversions
Список конверсий (заказов) по рассылке.

#### GET /api/broadcasts/dashboard
Дашборд с общей аналитикой по рассылкам.

**Query Parameters:**
- `period` (enum: week, month, quarter, year, all)

**Response (200):**
```json
{
  "success": true,
  "data": {
    "total_campaigns": 45,
    "active_triggers": 5,
    "total_sent": 67500,
    "total_conversions": 890,
    "total_revenue": 3200000,
    "avg_conversion_rate": 1.32
  }
}
```

### 5.4 Эндпоинты для триггеров

#### GET /api/broadcasts/triggers
Список триггерных рассылок.

**Response (200):**
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": 10,
        "name": "Возврат после 30 дней",
        "trigger_type": "inactive_users",
        "is_active": true,
        "last_run_at": "2024-01-25T10:00:00Z"
      }
    ]
  }
}
```

#### PUT /api/broadcasts/:id/toggle
Включение/выключение триггерной рассылки.

---

## 6. Интерфейс администратора

### 6.1 Структура страниц

#### 6.1.1 Главная страница рассылок

**Путь:** `/admin/broadcasts`

**Элементы:**
- Кнопка "Создать рассылку"
- Кнопка "Управление сегментами"
- Табы: Все рассылки, Ручные, Триггерные
- Фильтры: Статус, Период, Поиск
- Таблица рассылок:
  - Название
  - Тип
  - Статус
  - Получателей
  - Отправлено
  - Кликов
  - Конверсий
  - Дата создания
  - Действия

#### 6.1.2 Создание/редактирование рассылки

**Путь:** `/admin/broadcasts/new` или `/admin/broadcasts/:id/edit`

**Секции:**

**1. Основные настройки**
- Название рассылки
- Описание
- Тип: Ручная / Триггерная

**2. Сегментация аудитории**
- Выбор сохраненного сегмента
- ИЛИ настройка условий:
  - Добавление условий
  - Выбор типа условия
  - Настройка параметров
  - Логические операторы (AND/OR)
  - Группировка условий
- Кнопка "Рассчитать аудиторию"
- Кнопка "Сохранить сегмент"

**3. Контент сообщения (WYSIWYG редактор)**
- Текстовый редактор:
  - Форматирование
  - Кнопка "Вставить плейсхолдер"
  - Счетчик символов (max 4096)
- Загрузка изображения:
  - Drag-and-drop зона
  - Предпросмотр
  - Кнопка "Удалить изображение"
- Кнопки (inline keyboard):
  - Список добавленных кнопок (max 8)
  - Поля для каждой кнопки: Текст, URL
  - Кнопка "+ Добавить кнопку"

**4. Планирование отправки**

Для ручных рассылок:
- Радио кнопки: "Отправить сейчас" / "Запланировать отправку"
- Если "Запланировать":
  - Дата и время отправки
  - Чекбокс "Учитывать часовой пояс пользователя"
  - Поле "Час отправки" (0-23)

Для триггерных рассылок:
- Выбор типа триггера
- Настройки триггера
- Время ежедневной проверки
- Чекбокс "Активировать триггер"

**5. Предпросмотр и тестирование**
- Выбор пользователя для предпросмотра
- Кнопка "Показать предпросмотр"
- Кнопка "Отправить тест"

**6. Действия**
- Кнопка "Сохранить черновик"
- Кнопка "Отправить"
- Кнопка "Активировать триггер"

#### 6.1.3 Детальная статистика рассылки

**Путь:** `/admin/broadcasts/:id`

**Секции:**

**1. Заголовок**
- Название рассылки
- Тип (badge)
- Статус (badge)
- Дата создания
- Кнопки действий

**2. Ключевые метрики (карточки)**
- Всего получателей
- Отправлено
- Ошибки
- Кликов (CTR)
- Конверсий (CR)
- Сумма заказов

**3. График отправки по времени**
- Timeline: отправлено/ошибки по часам

**4. Статистика по кнопкам**
- Таблица: Текст кнопки, Количество кликов, Процент

**5. Контент рассылки**
- Отображение текста сообщения
- Изображение
- Кнопки

**6. Сегментация**
- Отображение использованных условий

**7. Таблица сообщений**
- Табы: Все, Отправленные, Ошибки
- Таблица:
  - Пользователь
  - Статус
  - Время отправки
  - Кликнул
  - Конвертировался
  - Ошибка

**8. Список конверсий**
- Таблица заказов:
  - Пользователь
  - Номер заказа
  - Сумма заказа
  - Дата заказа
  - Дней после рассылки

#### 6.1.4 Управление сегментами

**Путь:** `/admin/broadcasts/segments`

**Элементы:**
- Кнопка "Создать сегмент"
- Таблица сегментов:
  - Название
  - Описание
  - Размер аудитории
  - Дата создания
  - Действия

#### 6.1.5 Дашборд аналитики

**Путь:** `/admin/broadcasts/dashboard`

**Элементы:**

**1. Фильтр периода**
- Выбор: Неделя, Месяц, Квартал, Год, Всё время

**2. Общая статистика (карточки)**
- Всего рассылок
- Активных триггеров
- Отправлено сообщений
- Конверсий
- Выручка от рассылок
- Средний CR

**3. График динамики**
- Линейный график: отправки, клики, конверсии

**4. Топ рассылок**
- Таблица: Название, CR, Выручка, Дата

**5. Последняя активность**
- Лента событий

---

## 7. Интеграция с существующей системой

### 7.1 Использование существующего Telegram бота

Модуль работает с тем же Telegram ботом, что и система уведомлений.

**Интеграция:**
- Единый `bot_token` из конфигурации
- Отдельная очередь `broadcast_queue` для рассылок
- Отдельный воркер `broadcast_worker` для отправки
- Telegram Bot API методы:
  - `sendMessage` - для текстовых сообщений
  - `sendPhoto` - для сообщений с изображением
  - `answerCallbackQuery` - для обработки кликов

**Обработка webhook Telegram:**
- Добавляется обработчик `callback_query` для отслеживания кликов
- При получении callback:
  - Извлекается `message_id` и `button_index`
  - Создается запись в `broadcast_clicks`
  - Отправляется ответ пользователю

### 7.2 Использование данных пользователей

**Требуемые поля из таблицы users:**
- `id`, `telegram_id`, `phone`, `first_name`, `last_name`
- `birth_date`, `city_id`, `timezone`
- `current_loyalty_level_id`, `loyalty_balance`
- `created_at`

**Требуемые поля из таблицы orders:**
- `user_id`, `status`, `total`, `created_at`, `branch_id`

### 7.3 Использование Redis для кеширования

**Кешируемые данные:**

**1. Размер сегмента**
- Ключ: `segment:size:{segment_id}`
- TTL: 24 часа

**2. Данные пользователя**
- Ключ: `user:broadcast:{user_id}`
- TTL: 1 час

**3. Конфигурация триггеров**
- Ключ: `triggers:active`
- TTL: 1 час

### 7.4 Использование WebSocket для real-time обновлений

**События для админ-панели:**

**1. Обновление статистики рассылки**
- Event: `broadcast:stats:update`
- Триггер: каждые 100 отправленных сообщений

**2. Завершение рассылки**
- Event: `broadcast:completed`
- Триггер: при завершении отправки

**3. Обновление статуса рассылки**
- Event: `broadcast:status:change`
- Триггер: при изменении статуса

### 7.5 Модульная архитектура

Модуль рассылок реализуется как отдельный модуль в монолитной архитектуре:

**Структура файлов:**
```
/backend
  /modules
    /broadcasts
      /models
      /services
      /workers
      /routes
      /validators
      /utils
      index.js
```

---

## 8. Технические требования

### 8.1 Производительность

**Отправка сообщений:**
- Соблюдение лимита Telegram API: 30 сообщений/секунду
- Фактическая скорость: 25-28 сообщений/секунду
- Время отправки рассылки на 10,000 пользователей: ~6-7 минут

**Формирование очереди:**
- Создание сообщений для 10,000 пользователей: < 30 секунд
- Батчинг: по 1000 записей за раз

**Запросы к БД:**
- Расчет размера сегмента: < 2 секунды
- Выборка данных пользователя: < 100ms (с кешем)
- Обновление статистики: < 500ms

**API эндпоинты:**
- Время ответа: < 300ms для 95% запросов
- Таймаут: 30 секунд для операций формирования очереди

### 8.2 Масштабируемость

**Горизонтальное масштабирование воркеров:**
- Возможность запуска нескольких экземпляров `BroadcastWorker`
- Блокировка задач через `locked_at` и `locked_by`
- Распределение нагрузки между воркерами

**Очередь задач:**
- Индексы для быстрой выборки задач
- Приоритизация (высокий/обычный)
- Retry механизм

**База данных:**
- Партицирование таблицы `broadcast_messages` при больших объемах
- Архивация старых рассылок (> 6 месяцев)

### 8.3 Надежность

**Обработка ошибок:**
- Логирование всех ошибок отправки
- Retry механизм (до 3 попыток)
- Экспоненциальная задержка: 5s, 15s, 60s

**Мониторинг:**
- Логирование времени выполнения воркеров
- Алерты при превышении времени
- Метрики: количество отправленных/failed сообщений

**Защита от перегрузки:**
- Rate limiting для API
- Ограничение размера батча
- Таймауты на cron задачи

### 8.4 Безопасность

**Авторизация:**
- Все эндпоинты требуют JWT токен
- Проверка роли администратора

**Валидация:**
- Валидация всех входных данных
- Проверка размера изображений (max 10 MB)
- Проверка допустимых URL
- Экранирование HTML

**Защита данных:**
- Персональные данные не передаются в frontend
- Логирование доступа к рассылкам

### 8.5 Конфигурация

**Переменные окружения:**
```
BROADCAST_WORKER_ENABLED=true
BROADCAST_WORKER_BATCH_SIZE=50
BROADCAST_WORKER_INTERVAL_MS=2000
BROADCAST_RATE_LIMIT=28
BROADCAST_RETRY_MAX=3
BROADCAST_RETRY_DELAYS=5,15,60
BROADCAST_CONVERSION_WINDOW_DAYS=7
BROADCAST_IMAGE_MAX_SIZE_MB=10
```

---

## 9. Этапы разработки

### Этап 1: Инфраструктура и база данных (10 часов)

**Задачи:**
1. Создание таблиц БД (2 часа)
2. Создание моделей (2 часа)
3. Создание индексов (2 часа)
4. Настройка Redis кеширования (2 часа)
5. Настройка структуры модуля (2 часа)

### Этап 2: Бизнес-логика сегментации (12 часов)

**Задачи:**
1. SegmentService - построение SQL запросов (6 часов)
2. Расчет размера аудитории (2 часа)
3. Сохраненные сегменты (2 часа)
4. Тестирование сегментации (2 часа)

### Этап 3: Бизнес-логика рассылок (14 часов)

**Задачи:**
1. BroadcastService - создание рассылок (4 часа)
2. PersonalizationService - персонализация (4 часа)
3. Формирование очереди сообщений (4 часа)
4. Предпросмотр и тестирование (2 часа)

### Этап 4: Воркер отправки (12 часов)

**Задачи:**
1. BroadcastWorker - основная логика (6 часов)
2. Обработка ошибок и retry (3 часа)
3. Интеграция с Telegram Bot API (2 часа)
4. Тестирование воркера (1 час)

### Этап 5: Триггерные рассылки (10 часов)

**Задачи:**
1. TriggerService - логика триггеров (4 часа)
2. TriggerWorker - cron задача (3 часа)
3. Настройка cron (1 час)
4. Тестирование триггеров (2 часа)

### Этап 6: Статистика и аналитика (10 часов)

**Задачи:**
1. StatisticsService - агрегация статистики (4 часа)
2. Отслеживание кликов (3 часа)
3. Отслеживание конверсий (3 часа)

### Этап 7: API эндпоинты (12 часов)

**Задачи:**
1. Эндпоинты для рассылок (4 часа)
2. Эндпоинты для сегментов (3 часа)
3. Эндпоинты для статистики (3 часа)
4. Эндпоинты для триггеров (2 часа)

### Этап 8: Админ-панель (Frontend) (20 часов)

**Задачи:**
1. Главная страница рассылок (4 часа)
2. Форма создания/редактирования (8 часов)
3. Страница детальной статистики (4 часа)
4. Управление сегментами (2 часа)
5. Дашборд аналитики (2 часа)

### Этап 9: Интеграция и тестирование (12 часов)

**Задачи:**
1. Интеграция с Telegram Bot (3 часа)
2. Интеграция с системой заказов (2 часа)
3. WebSocket интеграция (2 часа)
4. Интеграционное тестирование (3 часа)
5. Нагрузочное тестирование (2 часа)

### Этап 10: Документация и развертывание (6 часов)

**Задачи:**
1. Техническая документация (2 часа)
2. Миграции БД (1 час)
3. Конфигурация production (1 час)
4. Развертывание (2 часа)

### Итоговое время разработки

| Этап | Часы |
|------|------|
| 1. Инфраструктура и база данных | 10 |
| 2. Бизнес-логика сегментации | 12 |
| 3. Бизнес-логика рассылок | 14 |
| 4. Воркер отправки | 12 |
| 5. Триггерные рассылки | 10 |
| 6. Статистика и аналитика | 10 |
| 7. API эндпоинты | 12 |
| 8. Админ-панель (Frontend) | 20 |
| 9. Интеграция и тестирование | 12 |
| 10. Документация и развертывание | 6 |
| **ИТОГО** | **118 часов** |

### Зависимости между этапами

**Последовательные этапы:**
- Этап 1 → Этапы 2, 3
- Этап 2 → Этап 3
- Этап 3 → Этапы 4, 5
- Этапы 4, 5, 6 → Этап 7
- Этап 7 → Этап 8
- Этапы 1-8 → Этап 9
- Этап 9 → Этап 10

**Параллельные этапы:**
- Этапы 4, 5, 6 можно выполнять параллельно
- Этапы 7 и 8 можно выполнять частично параллельно

---

## Заключение

Модуль маркетинговых рассылок интегрируется в существующую систему без нарушения работы других компонентов.

**Ключевые преимущества:**
- **Модульная архитектура** - легко поддерживать и расширять
- **Производительность** - оптимизированные запросы и кеширование
- **Надежность** - retry механизмы и мониторинг
- **Гибкость** - сложная сегментация и персонализация
- **Аналитика** - детальная статистика для принятия решений
